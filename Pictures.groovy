@Grapes([
@Grab(group='org.apache.tika', module='tika-core', version='1.14'),
@Grab(group='org.apache.tika', module='tika-parsers', version='1.14'),
@Grab(group='commons-io', module='commons-io', version='2.5'),
@Grab(group='commons-lang', module='commons-lang', version='2.6'),
@Grab(group='org.hsqldb', module='hsqldb', version='2.3.4'),
@GrabConfig(systemClassLoader=true)
])

import groovy.io.*
import groovy.sql.Sql
import groovy.time.*
import groovy.json.*
import groovy.util.logging.Log
import static groovyx.gpars.GParsPool.withPool
import java.nio.file.*
import DBHelper
import org.apache.commons.io.FilenameUtils
import org.apache.commons.lang.exception.ExceptionUtils

import org.apache.tika.parser.AutoDetectParser
import org.apache.tika.parser.ParseContext
import org.apache.tika.parser.Parser
import org.apache.tika.metadata.Metadata
import org.apache.tika.metadata.TikaCoreProperties
import org.apache.tika.sax.BodyContentHandler

import java.util.concurrent.atomic.*
import java.util.concurrent.*

class ImageFile {
  String file
  String ftype 
  String dateHash
  String error = null
  String errorStack = null
  Path destFile
  Path srcFile
  int size
  boolean foundEXIF
  Date date = null
  String gpsDescription
  double latitude = 0.0
  double longitude = 0.0

  String toString() {
    if(error != null) return "File: $file Type: $ftype Error: $error"
    if(date == null) return "File: $file Type: $ftype"
    if(gpsDescription == null) return "File: $file Type: $ftype Date: $date"
    return "File: $file Type: $ftype Date: $date Lat(E): $latitude Long(N): $longitude"
  }

  String printDetails() {
    def lines = []
    lines << "File: $file"
    if(date != null) lines << "Date: $date"
    if(gpsDescription != null) lines << "GPS Location: $gpsDescription"
    if(latitude > 0) lines << "Latitude North: $latitude Longitude East: $longitude" 
    lines << "Destination: ${destFile.toString()}" 
    if(error != null) lines << "Error: $error" 
    if(errorStack != null) lines << "StackTrace: $errorStack" 
    return lines.join("\r\n")
  }
}

@Log
class ImageOrganizer {
  Vector others = []
  def dupMap = []
  def sql = null

  String srcD = null
  String destD = null
  def excludes = []
  int totalfiles = 0

  public ImageOrganizer() {
   sql = Sql.newInstance('jdbc:hsqldb:file:testdb', 'SA', '', 'org.hsqldb.jdbc.JDBCDriver')
   initDataBase()
  }

  public initDataBase() {
    if(sql != null) {
      sql.execute("CREATE TABLE IF NOT EXISTS Pictures (id integer generated by default as identity, src varchar(800), filetype varchar(100), createdate timestamp, latitude double, longitude decimal, md5 varchar(500))")
      sql.execute("CREATE TABLE IF NOT EXISTS PicturesTemp (id integer generated by default as identity, src varchar(800), filetype varchar(100), createdate timestamp, latitude double, longitude decimal, md5 varchar(500), synced boolean)")
      sql.execute("CREATE TABLE IF NOT EXISTS History (id integer generated by default as identity, imgcount integer, notes varchar(800), importdate timestamp, status varchar(1)")
      sql.execute("DELETE FROM PicturesTemp")
    }
  }

  def executeCommand(command) {
    if(sql != null) {
      try {
        sql.query(command) { resultSet ->  
          DBHelper.showResults(resultSet, DBHelper.pickColumns(sql, resultSet.getMetaData(), true), 100)
        }
      } catch(e) {
        System.out.println(e.getMessage())
      }
    }
  }
  
  def findDuplicates() {
    executeCommand("select MIN(Id) AS RowToKeep, md5 from PicturesTemp GROUP BY md5 HAVING COUNT(*) > 1")
  }
  
  def removeDuplicates() {
    sql.execute("DELETE FROM PicturesTemp Where ID in (select MIN(Id) from PicturesTemp GROUP BY md5 HAVING COUNT(*) > 1)")
  }
  
  def findSaved() {
    executeCommand("SELECT P.SRC, T.SRC, P.CreateDate, T.CreateDate from Pictures P INNER JOIN PicturesTemp T Where P.md5 = T.md5")
  }
  
  def removeSaved() {
    sql.execute("DELETE FROM PicturesTemp WHERE ID IN (SELECT T.ID as ID from Pictures P INNER JOIN PicturesTemp T Where P.md5 = T.md5")
  }

  def writeToDestination(test=False) {
    
    
    withPool() {
      images.each {
        Files.createDirectories(image.destFile.getParent())
        Files.copy(srcFile, image.destFile, StandardCopyOption.REPLACE_EXISTING)
      }
    }
  }

  def checkRepository() {
    Path p = Paths.get(destD)
    def filelist = []
    p.eachFileRecurse(FileType.FILES) {
      String fname = it.toString()
      filelist.add(fname) 
    }
    totalfiles = filelist.size()
    withPool() {
      filelist.each { processFileTika(it, true) }
    }
  }

  def processFiles() {
    Path p = Paths.get(srcD)
    def filelist = []
    p.eachFileRecurse(FileType.FILES) {
      String fname = it.toString()
      boolean exclude = false
      excludes.each {
        if(fname.endsWith(it)) exclude = true
      }
      if(!exclude) filelist.add(fname) 
    }
    totalfiles = filelist.size()
    withPool() {
      filelist.each { processFileTika(it, false) }
    }
  }

  def processFileTika(imageFile, checkCache) {
      def insert = false
      File file = new File(imageFile);
      
      ImageFile image = new ImageFile()
      image.file = file.getAbsolutePath()
      image.srcFile = Paths.get(imageFile)

      //Parser method parameters
      Parser parser = new AutoDetectParser();
      BodyContentHandler handler = new BodyContentHandler();
      Metadata metadata = new Metadata();
      FileInputStream inputstream = new FileInputStream(file);
      FileInputStream inputHashstream = new FileInputStream(file);
      ParseContext context = new ParseContext();
      
      try {
        parser.parse(inputstream, handler, metadata, context);
        String md5 = org.apache.commons.codec.digest.DigestUtils.md5Hex(inputHashStream);
        Date date = metadata.getDate(TikaCoreProperties.CREATED)
        String ftype = metadata.get(Metadata.CONTENT_TYPE)
        String lat = metadata.get(TikaCoreProperties.LATITUDE)
        String longt = metadata.get(TikaCoreProperties.LONGITUDE)

        if(date != null) image.date = date
        if(ftype != null) image.ftype = ftype
        if(lat != null) image.latitude = lat as double
        if(longt != null) image.longitude = longt as double
        if(lat != null && longt != null) image.gpsDescription = "Latitude: ${lat} Longitude: ${longt}"
        image.hash = md5
        
        if(image.date == null) {
          image.destFile = Paths.get(destD,"UNDATED",image.srcFile.getFileName().toString())
        }
        else {
          image.destFile = Paths.get(destD,
                            image.date.format("yyyy"),image.date.format("MMM"),image.date.format("d"),image.date.format("HH_mm_ss")
                            +"."+FilenameUtils.getExtension(imageFile))
                            "_"+ image.date.format("d") + image.date.format("HH_mm_ss")
        }
        if(ftype.indexOf("octet-stream") == -1) image.foundEXIF = true

      } catch(all) {
        image.foundEXIF = false
        image.error = all.getMessage()
        image.errorStack = ExceptionUtils.getStackTrace(all)
      }
      if(image.foundEXIF) {
        def insert = true
        def table =  "Pictures"
        if(checkCache) {
          def rows = sql.rows("SELECT Id from Pictures WHERE ID = ${image.hash}")
          if( rows.size() > 0 ) insert = false
          table = "PicturesTemp"
        }
        if(insert) {
          sql.execute("insert into $table (id, src, filetype, createdate, latitude, longitude, md5, synced) values (null, ${image.file}, ${image.ftype}, ${image.date}, ${image.latitude}, ${image.longitude}, ${image.hash}, false)") 
        }
      }
      else others.add(image)
      return insert 
  }
}

def cli = new CliBuilder(usage:'Pictures.groovy -s SourceDirectory -d DestinationDirectory')

cli.with {
  h longOpt: 'help', 'Show usage information.'
  s longOpt: 'source', args: 1, argName: 'src', 'The source directory in which to look for image files.'
  e longOpt: 'exclude', args: 1, argName: 'exclude', 'The extensions to exclude in the source directory.'
  d longOpt: 'destination', args: 1, argName: 'destination', 'The destination directory where the files are organized based on the date the picture was taken.'
}

def options = cli.parse(args)
  
if(!options || options.h || args.length == 0) {
  cli.usage()
  return
}

def extraArgs = options.arguments()

String dest = "Photos"
String src = "."

if(options.d) dest = options.d
if(options.s) src = options.s

def io = new ImageOrganizer(srcD: src, destD: dest)
if(options.e) io.excludes = options.e.tokenize(",")

Date timeStarted = new Date()

Thread.startDaemon {
  io.processFiles()
}


boolean keepProcessing = true
def prompt = "io> "
def command = null

while(keepProcessing) {
  command = System.console().readLine prompt
  if(command == null) continue
  cmd = command.toLowerCase().tokenize(' ')
  if(cmd[0] == "help") {
    println "The following commands are supported:"
    println "exit               Exit the program."
    println "status             Print status."
    println "select ...         Any query against the picture database [Table:Pictures]."
    println "others             Print the names of the files that were not recognized as images."
    println "dedup report       Find duplicates based on time and report them."
    println "images             Print the names of image files that have been read."
    println "image index        Print the details of the image at index."
    println "copyTest           Prints what the copy operation would do."
    println "copy               Copies the files to the destination folder."
  } else if (cmd[0] == "exit") {
    keepProcessing = false
  } else if (cmd[0] == "status") {
    Date now = new Date()
    double percentDone = ((((io.images.size() + io.others.size())/(double)io.totalfiles)*10000.0) as int)/100 //
    println "Time Elapsed: ${TimeCategory.minus(now,timeStarted)} Total Files: ${io.totalfiles} Files Processed (%): ${percentDone}"
    println "Found ${io.images.size()} images and ${io.others.size()} other unrecognized files."
  } else if (cmd[0] == "others") {
    io.others.eachWithIndex { elem, indx -> println "${indx}] $elem" }
  } else if (cmd[0] == "images") {
    io.images.eachWithIndex { elem, indx -> println "${indx}] $elem" }
  } else if (cmd[0] == "dedup" && cmd[1] == "report") {
    io.findDuplicates()
    io.dupMap.each { name, value ->
      if (value.size()> 1) {
        println "Duplicate entries for the name $name"
        value.each { println "-- ${it}" }
      }
    }
  } else if ((cmd[0] == "image" || cmd[0] == "other") && cmd.size() > 1 && cmd[1].isInteger()) {
    int index = cmd[1] as int
    def list = (cmd[0] == "image")? io.images : io.others
    if(list.size() > index) {
      ImageFile im = list[index]
      println im.printDetails()
    } else {
      println "There are only ${list.size()} files in the {cmd[0]} list. The index specified [${index}] was higher."
    }
  } else if(cmd[0] == "filter" && cmd.size() > 1) {
    if(cmd[1] == "type" && cmd.size()>2) {
      
    }
  } else if(cmd[0] =="select") {
    io.executeCommand(command)
  } else {
    println "Invalid command. Please type help to see your options."
  }

}
